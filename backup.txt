	def nextLeaf(self, state):
		tempState = state
		result = self.next(state)
		while result:
			tempState += result
			result = m.next(tempState)
		return tempState

	def nextLeafs(self, state):
		if self.hasState(state):
#			return [self.nextLeaf(state+leaf) for leaf in list(self.table[state].keys())]
			leafs = sorted(self.table[state], key=lambda key:self.table[state])
			leafs.reverse()
			return leafs
		else:
			return None
			
def getPairsCompletions(text, separator=' '):
	pairList = []
	for word in text.split(separator):
		for i in range(len(word)-1):
			pairList.append((word[:i+1], word[i+1:]))
	return pairList
	
def getPairs(text, separator=' '):
	pairList = []
	symbol = ''
	for i in range(len(text)):
		if i+1 < len(text):
			if text[i+1] != separator and text[i] != separator:
				if symbol == '':
					symbol = text[i]
					pairList.append((symbol, text[i+1]))
					symbol += text[i+1]
				else:
					pairList.append((symbol, text[i+1]))
					symbol += text[i+1]
			else:
				symbol = ''
	return pairList

def train(markov, pairList):
	for pair in pairList:
		markov.increaseRelation(pair[0], pair[1])
